|   |
|---|
|**Code**|
|```<br>//@version=6<br>strategy("Logistic Direction Model (Price/Volume) - Horizon Scoring", overlay=true,<br>     initial_capital=1000,<br>     commission_type=strategy.commission.percent, commission_value=0.05,<br>     slippage=1)<br><br>// =========================<br>// Inputs<br>// =========================<br>horizonBars      = input.int(5, "Horizon (bars)", minval=1) // e.g. 5 for ~1 week on Daily<br>useVolume        = input.bool(true, "Use volume features")<br>useRegimeFilter  = input.bool(true, "Use regime filter (trend vs chop)")<br><br>probThreshold    = input.float(0.60, "Entry threshold P(up)", minval=0.0, maxval=1.0, step=0.01)<br>probExit         = input.float(0.45, "Exit threshold P(up)", minval=0.0, maxval=1.0, step=0.01)<br><br>riskMode         = input.string("Fixed %", "Exit mode", options=["Fixed %", "ATR"])<br>tpPct            = input.float(6.0, "Take profit %", minval=0.1, step=0.1)<br>slPct            = input.float(3.0, "Stop loss %", minval=0.1, step=0.1)<br>atrLen           = input.int(14, "ATR length", minval=2)<br>tpAtrMult        = input.float(2.0, "TP ATR mult", minval=0.1, step=0.1)<br>slAtrMult        = input.float(1.5, "SL ATR mult", minval=0.1, step=0.1)<br><br>tradeLongOnly    = input.bool(true, "Long only")<br>allowShort       = input.bool(false, "Allow short (if not long-only)")<br>maxOneTrade      = input.bool(true, "One position at a time")<br><br>// =========================<br>// Model weights (tune these)<br>// =========================<br>bias             = input.float(0.00, "w0 Bias", step=0.01)<br><br>wMom1            = input.float(0.90, "w1 Momentum(ROC) 1", step=0.01)<br>wMom2            = input.float(0.60, "w2 Momentum(ROC) 2", step=0.01)<br>wEmaDist         = input.float(0.70, "w3 EMA distance", step=0.01)<br>wVol             = input.float(-0.50, "w4 Volatility penalty", step=0.01)<br>wRsi             = input.float(0.30, "w5 RSI tilt", step=0.01)<br><br>wVolZ            = input.float(0.35, "w6 Volume z-score", step=0.01)<br>wVolPrice        = input.float(0.25, "w7 Volume*Return interaction", step=0.01)<br><br>wRegime          = input.float(0.60, "w8 Regime boost (trend)", step=0.01)<br><br>// =========================<br>// Feature engineering<br>// =========================<br>// All features are scaled-ish to be roughly comparable.<br>// You MUST keep scaling stable across symbols/timeframes.<br><br>roc1Len = input.int(5,  "ROC1 length", minval=1)<br>roc2Len = input.int(20, "ROC2 length", minval=2)<br>emaLen  = input.int(50, "EMA length",  minval=2)<br>volLen  = input.int(20, "Volatility length", minval=5)<br>rsiLen  = input.int(14, "RSI length", minval=2)<br><br>ret1 = math.log(close / close[1])<br>roc1 = ta.roc(close, roc1Len) / 100.0<br>roc2 = ta.roc(close, roc2Len) / 100.0<br><br>ema  = ta.ema(close, emaLen)<br>emaDist = (close - ema) / ema // relative distance<br><br>// Realized vol proxy: stdev of log returns<br>vol = ta.stdev(ret1, volLen)<br><br>// RSI normalized around 0<br>rsi = ta.rsi(close, rsiLen)<br>rsiTilt = (rsi - 50.0) / 50.0<br><br>// Volume features<br>float volZ = na<br>float volPriceInteraction = na<br>if useVolume<br>    vSma = ta.sma(volume, 20)<br>    vStd = ta.stdev(volume, 20)<br>    volZ := vStd \> 0 ? (volume - vSma) / vStd : 0.0<br>    volPriceInteraction := volZ * ret1<br><br>// Regime filter: trend vs chop using ADX + slope<br>diLen = input.int(14, "DI length", minval=2)<br>adxSmoothing = input.int(14, "ADX smoothing", minval=2)<br>[plusDI, minusDI, adx] = ta.dmi(diLen, adxSmoothing)<br>emaSlope = (ema - ema[5]) / ema[5]<br>isTrend = (adx \> 18) and (math.abs(emaSlope) \> 0.001)<br><br>regime = useRegimeFilter ? (isTrend ? 1.0 : 0.0) : 0.0<br><br>// =========================<br>// Logistic probability<br>// =========================<br>x = bias + wMom1 * roc1 + wMom2 * roc2 + wEmaDist * emaDist + wVol  * vol + wRsi  * rsiTilt + (useVolume ? (wVolZ * nz(volZ) + wVolPrice * nz(volPriceInteraction)) : 0.0) + wRegime * regime<br><br>// Sigmoid with numeric safety<br>sigmoid(z) =\><br>    // clamp to avoid overflow<br>    zz = math.max(math.min(z, 20.0), -20.0)<br>    1.0 / (1.0 + math.exp(-zz))<br><br>pUp = sigmoid(x)<br><br>// =========================<br>// Optional label approximation (for on-chart sanity check)<br>// =========================<br>// Forward return sign after horizonBars (not usable in realtime; for visual audit only).<br>float fwdRet = na<br>fwdRet := bar_index \> horizonBars ? (close[horizonBars] != 0 ? (close - close[horizonBars]) / close[horizonBars] : na) : na<br>// Note: fwdRet here references past/future depending on indexing; keep it only for offline inspection.<br><br>// =========================<br>// Trading rules<br>// =========================<br>canEnter = maxOneTrade ? (strategy.position_size == 0) : true<br><br>longSignal  = canEnter and (pUp \>= probThreshold)<br>exitLong    = (pUp \<= probExit)<br><br>shortSignal = canEnter and (pUp \<= (1.0 - probThreshold)) and allowShort and (not tradeLongOnly)<br>exitShort   = (pUp \>= (1.0 - probExit)) and allowShort and (not tradeLongOnly)<br><br>// Entries<br>if longSignal and (tradeLongOnly or allowShort)<br>    strategy.entry("L", strategy.long)<br><br>if shortSignal<br>    strategy.entry("S", strategy.short)<br><br>// Exits: probability-based + risk-based<br>atr = ta.atr(atrLen)<br><br>if strategy.position_size \> 0<br>    if exitLong<br>        strategy.close("L", comment="PExit")<br>    if riskMode == "Fixed %"<br>        longStop = strategy.position_avg_price * (1.0 - slPct / 100.0)<br>        longTake = strategy.position_avg_price * (1.0 + tpPct / 100.0)<br>        strategy.exit("L-Exit", from_entry="L", stop=longStop, limit=longTake)<br>    else<br>        longStop = strategy.position_avg_price - slAtrMult * atr<br>        longTake = strategy.position_avg_price + tpAtrMult * atr<br>        strategy.exit("L-Exit", from_entry="L", stop=longStop, limit=longTake)<br><br>if strategy.position_size \< 0<br>    if exitShort<br>        strategy.close("S", comment="PExit")<br>    if riskMode == "Fixed %"<br>        shortStop = strategy.position_avg_price * (1.0 + slPct / 100.0)<br>        shortTake = strategy.position_avg_price * (1.0 - tpPct / 100.0)<br>        strategy.exit("S-Exit", from_entry="S", stop=shortStop, limit=shortTake)<br>    else<br>        shortStop = strategy.position_avg_price + slAtrMult * atr<br>        shortTake = strategy.position_avg_price - tpAtrMult * atr<br>        strategy.exit("S-Exit", from_entry="S", stop=shortStop, limit=shortTake)<br><br>// =========================<br>// Plots<br>// =========================<br>plot(pUp, "P(up)", linewidth=2)<br>hline(probThreshold, "Entry Th", linestyle=hline.style_dotted)<br>hline(probExit, "Exit Th", linestyle=hline.style_dotted)<br><br>plot(useRegimeFilter ? regime : na, "Regime(Trend=1)", style=plot.style_stepline)<br>.<br>```|