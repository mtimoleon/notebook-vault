Για να το έχεις **πραγματικά αυτόματο** και **εδώ-και-τώρα**, δίνω έτοιμη λύση με **Google Apps Script** που:

- Διαβάζει **όλα τα νέα emails από το τελευταίο run**.
- Τα **ομαδοποιεί ανά αποστολέα**.
- Καλεί **OpenAI Responses API** για σύνοψη στα ελληνικά (TL;DR + 8–12 bullets + σχόλιο).
- Σου στέλνει **email digest** (και βάζει **label “Summarized”** + τα κάνει **read**).
- Ρυθμίζεις **triggers** 08:30, 18:30, 22:30.

Απλά βήματα

1. Άνοιξε [https://script.google.com](https://script.google.com) → New project.
2. Αντικατάστησε το περιεχόμενο με τον παρακάτω κώδικα.
3. Βάλε το OpenAI API key σου στη μεταβλητή.
4. Από Triggers φτιάξε 3 χρονόμετρα: 08:30, 18:30, 22:30 να καλούν runDigest.
5. Τρέξε μια φορά runDigest (Authorize).
 
|   |
|---|
|**Code**|
|```<br>// == CONFIG ==<br>const OPENAI_API_KEY = "YOUR_OPENAI_API_KEY";<br>const OPENAI_MODEL = "gpt-5"; // or another text-capable model<br>const GMAIL_LINK_ALL = "https://mail.google.com/mail/u/0/#inbox";<br>const LABEL_SUMMARIZED = "Summarized";<br>const MAX_PER_SENDER_CHARS = 8000;   // cap input per sender to keep tokens safe<br>const LOOKBACK_MINUTES_DEFAULT = 720; // first run: 12h<br><br>// == ENTRYPOINT ==<br>function runDigest() {<br>  const props = PropertiesService.getScriptProperties();<br>  const lastRunMs = Number(props.getProperty("lastRunMs") \| "0");<br>  const nowMs = Date.now();<br>  const lookbackMs = lastRunMs ? (nowMs - lastRunMs) : LOOKBACK_MINUTES_DEFAULT * 60 * 1000;<br><br>  // 1) Fetch candidates (newer_than:1d) and then filter by internalDate \> lastRun<br>  const threads = GmailApp.search('newer_than:1d'); // broad fetch<br>  const msgs = [];<br>  threads.forEach(t =\> {<br>    t.getMessages().forEach(m =\> {<br>      const ts = m.getDate().getTime();<br>      if (!lastRunMs \| ts \> lastRunMs) msgs.push(m);<br>    });<br>  });<br>  if (msgs.length === 0) {<br>    props.setProperty("lastRunMs", String(nowMs));<br>    return; // nothing new<br>  }<br><br>  // 2) Group by sender<br>  const groups = {}; // { sender: [ {subject, text, date, id, threadId} ] }<br>  msgs.forEach(m =\> {<br>    const from = (m.getFrom() \| "Unknown").replace(/\r?\n/g, " ").trim();<br>    const subject = (m.getSubject() \| "(no subject)").trim();<br>    const bodyHtml = m.getBody();<br>    const text = stripHtml(bodyHtml).slice(0, 20000); // hard cap per message<br>    const key = from;<br>    if (!groups[key]) groups[key] = [];<br>    groups[key].push({<br>      subject,<br>      text,<br>      date: m.getDate(),<br>      id: m.getId(),<br>      threadId: m.getThread().getId()<br>    });<br>  });<br><br>  // 3) Build prompt per sender (truncate)<br>  const perSenderInputs = [];<br>  Object.keys(groups).forEach(sender =\> {<br>    const items = groups[sender]<br>      .sort((a,b) =\> a.date - b.date)<br>      .map(x =\> `• ${fmtDate(x.date)} — ${x.subject}\n${truncate(x.text, MAX_PER_SENDER_CHARS)}`)<br>      .join("\n\n");<br>    perSenderInputs.push({ sender, content: items });<br>  });<br><br>  // 4) Ask OpenAI for a consolidated digest<br>  const fullInput =<br>`Γράψε σύνοψη στα ελληνικά ανά αποστολέα, με τη μορφή:<br>- TL;DR (μία πρόταση)<br>- 8–12 bullets με βασικά σημεία, ημερομηνίες, λεπτομέρειες<br>- 1 σύντομο contextual σχόλιο<br>Μην επαναλαμβάνεις ασήμαντα footer/unsubscribe.<br><br>Υλικό ομαδοποιημένο ανά αποστολέα:<br>${perSenderInputs.map(x =\> `\n[ΑΠΟΣΤΟΛΕΑΣ: ${x.sender}]\n${x.content}`).join("\n")}`;<br><br>  const summary = callOpenAI(fullInput);<br><br>  // 5) Email the digest to myself<br>  const subject = `Email Digest — ${fmtDate(new Date())}`;<br>  const body =<br>    `Ομαδοποιημένες περιλήψεις:\n\n${summary}\n\n` +<br>    `Γενικό link Gmail: ${GMAIL_LINK_ALL}\n` +<br>    `Συνοψίστηκαν ${msgs.length} μηνύματα.`;<br><br>  GmailApp.sendEmail(Session.getActiveUser().getEmail(), subject, body);<br><br>  // 6) Label + mark read on included threads<br>  const label = getOrCreateLabel(LABEL_SUMMARIZED);<br>  const threadIds = new Set(msgs.map(m =\> m.getThread().getId()));<br>  GmailApp.getThreadsByIds([...threadIds]).forEach(th =\> {<br>    th.addLabel(label);<br>    th.markRead();<br>  });<br><br>  // 7) Persist lastRun<br>  props.setProperty("lastRunMs", String(nowMs));<br>}<br><br>// == OPENAI ==<br>function callOpenAI(inputText) {<br>  const url = "https://api.openai.com/v1/responses";<br>  const payload = {<br>    model: OPENAI_MODEL,<br>    input: [{ role: "user", content: inputText }],<br>  };<br>  const resp = UrlFetchApp.fetch(url, {<br>    method: "post",<br>    muteHttpExceptions: true,<br>    contentType: "application/json",<br>    headers: { Authorization: `Bearer ${OPENAI_API_KEY}` },<br>    payload: JSON.stringify(payload)<br>  });<br>  if (resp.getResponseCode() \>= 300) {<br>    throw new Error(`OpenAI error ${resp.getResponseCode()}: ${resp.getContentText()}`);<br>  }<br>  const data = JSON.parse(resp.getContentText());<br>  // Try common fields<br>  if (data.output_text) return data.output_text;<br>  if (data.output) return typeof data.output === "string" ? data.output : JSON.stringify(data.output);<br>  return JSON.stringify(data);<br>}<br><br>// == UTIL ==<br>function stripHtml(html) {<br>  return html<br>    .replace(/\<style[\s\S]*?\<\/style\>/gi, " ")<br>    .replace(/\<script[\s\S]*?\<\/script\>/gi, " ")<br>    .replace(/\<[^\>]+\>/g, " ")<br>    .replace(/\s+/g, " ")<br>    .trim();<br>}<br>function truncate(s, n) { return s.length \> n ? s.slice(0, n) : s; }<br>function fmtDate(d) {<br>  if (!(d instanceof Date)) d = new Date(d);<br>  const pad = (x)=\>String(x).padStart(2,"0");<br>  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;<br>}<br>function getOrCreateLabel(name) {<br>  const existing = GmailApp.getUserLabelByName(name);<br>  return existing \| GmailApp.createLabel(name);<br>}<br><br>// Optional: create 3 daily triggers at :30<br>function createDigestTriggers() {<br>  // 08:30<br>  ScriptApp.newTrigger("runDigest").timeBased().everyDays(1).atHour(8).nearMinute(30).create();<br>  // 18:30<br>  ScriptApp.newTrigger("runDigest").timeBased().everyDays(1).atHour(18).nearMinute(30).create();<br>  // 22:30<br>  ScriptApp.newTrigger("runDigest").timeBased().everyDays(1).atHour(22).nearMinute(30).create();<br>}<br>```|
 
Με αυτό:

- Θα έχεις **πλήρως αυτόματη** σύνοψη 3 φορές/ημέρα.
- Θα βλέπεις email-digest στο inbox σου.
- Τα σχετικά emails θα παίρνουν **label “Summarized”** και θα γίνονται **read**.

Αν θες, μπορώ να προσαρμόσω:

- lookback/φίλτρα (π.χ. μόνο συγκεκριμένοι αποστολείς),
- διαφορετικό format εξόδου,
- HTML email με ωραία κεφαλίδες και link που έστειλες.